<?php

namespace App\Traits;

use Carbon\Carbon;
use Illuminate\Support\Str;
use App\Http\Resources\Report as ReportResource;
use App\Http\Resources\Reports as ReportsResource;

trait ReportTraits
{
    public $report = null;

    /**
     *  This method transforms a collection or single model instance
     */
    public function convertToApiFormat($collection = null)
    {
        try {

            // If this instance is a collection or a paginated collection
            if( $collection instanceof \Illuminate\Support\Collection ||
                $collection instanceof \Illuminate\Pagination\LengthAwarePaginator ){

                //  Transform the multiple instances
                return new ReportsResource($collection);

            // If this instance is not a collection
            }elseif($this instanceof \App\Report){

                //  Transform the single instance
                return new ReportResource($this);

            }else{

                return $collection ?? $this;

            }

        } catch (\Exception $e) {

            throw($e);

        }
    }

    /**
     *  This method generates a resource creation report
     */
    public function generateResourceCreationReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Created', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource converted report
     */
    public function generateResourceConvertedReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Converted', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource abandoned report
     */
    public function generateResourceAbandonedReport($model, $metadata = [], $store_id = null, $location_id = null, $overide_record = [])
    {
        return $this->generateReport('Abandoned', $model, $metadata, $store_id, $location_id, $overide_record);
    }

    /**
     *  This method generates a resource recycled report
     *  Used for shortcodes
     */
    public function generateResourceRecycledReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Recycled', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource abandoned report
     *  Used for carts
     */
    public function generateResourceRecoveredReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Recovered', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource visited report
     */
    public function generateResourceVisitedReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Visited', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource product existence report
     */
    public function generateResourceProductExistenceReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Product Existence', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource coupon existence report
     */
    public function generateResourceCouponExistenceReport($model, $metadata = [], $store_id = null, $location_id = null)
    {
        return $this->generateReport('Coupon Existence', $model, $metadata, $store_id, $location_id);
    }

    /**
     *  This method generates a resource creation report
     */
    public function generateReport($type, $model, $metadata, $store_id, $location_id, $overide_record = [])
    {
        //  Set the report record
        $record = [
            'type' => $type,
            'metadata' => $metadata,
            'store_id' => $store_id,
            'location_id' => $location_id,
            /**
             *  Set the user id if available.
             *  Note that the system runs background processes that require the system to log
             *  reports, however since an authenticated user is not present this value may not
             *  be set for reports generated by the system.
             */
            'user_id' => auth('api')->user() ? auth('api')->user()->id : null,
        ];

        $record = array_merge($record, $overide_record);

        //  Create a new report
        return ( new \App\Report() )->createResource($record, $model);

    }

    /**
     *  This method creates a new report
     */
    public function createResource($data = [], $model = null)
    {
        try {

            //  Extract the Request Object data (CommanTraits)
            $data = $this->extractRequestData($data);

            /**
             *  Create a new resource
             */
            $this->report = $this->create($data);

            //  If created successfully
            if ( $this->report && $model) {

                //  Set the model as the report owner
                $this->report->setResourceOwner($model);

                //  Return the report
                return $this->report;

            }

        } catch (\Exception $e) {

            throw($e);

        }

    }

    /**
     *  This method returns a list of reports
     */
    public function getResources($data = [], $builder = null, $paginate = true, $convert_to_api_format = true)
    {
        try {

            //  Extract the Request Object data (CommanTraits)
            $data = $this->extractRequestData($data);

            //  Validate the data (CommanTraits)
            $this->getResourcesValidation($data);

            //  If we already have an eloquent builder defined
            if( is_object($builder) ){

                //  Set the reports to this eloquent builder
                $reports = $builder;

            }else{

                //  Get the reports
                $reports = \App\Report::latest();

            }

            //  Filter the reports
            $reports = $this->filterResources($data, $reports);

            //  Return reports
            return $this->collectionResponse($data, $reports, $paginate, $convert_to_api_format);

        } catch (\Exception $e) {

            throw($e);

        }
    }

    /**
     *  This method filters the reports by search or status
     */
    public function filterResources($data = [], $reports)
    {
        //  If we need to search for specific reports
        if ( isset($data['search']) && !empty($data['search']) ) {

            $reports = $this->filterResourcesBySearch($data, $reports);

        }else{

            if ( isset($data['type']) && !empty($data['type']) ) {

                $reports = $this->filterResourcesByType($data, $reports);

            }

            if ( isset($data['owner_type']) && !empty($data['owner_type']) ) {

                $reports = $this->filterResourcesByOwnerType($data, $reports);

            }

            if ( isset($data['start_date']) && !empty($data['start_date']) ) {

                $reports = $this->filterResourcesByStartDate($reports, $data['start_date']);

            }

            if ( isset($data['end_date']) && !empty($data['end_date']) ) {

                $reports = $this->filterResourcesByEndDate($reports, $data['end_date']);

            }

        }

        //  Return the reports
        return $reports;
    }

    /**
     *  This method filters the reports by search
     */
    public function filterResourcesBySearch($data = [], $reports)
    {
        //  Set the search term e.g "Bravo Cinema"
        $search_term = $data['search'] ?? null;

        //  Return searched reports otherwise original reports
        return empty($search_term) ? $reports : $reports->search($search_term);

    }

    /**
     *  This method filters the reports by type
     */
    public function filterResourcesByType($data = [], $reports)
    {
        //  Set the types to an empty array
        $types = [];

        //  Set the type filters e.g ["created", "removed", "visited", ...] or "created,removed,visited, ..."
        $type_filters = $data['type'] ?? $data;

        //  If the filters are provided as String format e.g "created,removed,visited"
        if( is_string($type_filters) ){

            //  Set the types to the exploded Array ["created", "removed", "visited"]
            $types = explode(',', $type_filters);

        }elseif( is_array($type_filters) ){

            //  Set the types to the given Array ["created", "removed", "visited"]
            $types = $type_filters;

        }

        //  Clean-up each type filter
        foreach ($types as $key => $type) {

            //  Convert " created " to "Created"
            $types[$key] = ucfirst(strtolower(trim($type)));

        }

        if ( $reports && count($types) ) {

            $reports->wherein('type', $types);

        }

        //  Return the reports
        return $reports;
    }

    /**
     *  This method filters the reports by owner types
     */
    public function filterResourcesByOwnerType($data = [], $reports)
    {
        //  Set the types to an empty array
        $types = [];

        //  Set the type filters e.g ["store", "location", "user", ...] or "store,location,user, ..."
        $type_filters = $data['owner_type'] ?? $data;

        //  If the filters are provided as String format e.g "created,removed,visited"
        if( is_string($type_filters) ){

            //  Set the types to the exploded Array ["store", "location", "user"]
            $types = explode(',', $type_filters);

        }elseif( is_array($type_filters) ){

            //  Set the types to the given Array ["store", "location", "user"]
            $types = $type_filters;

        }

        //  Clean-up each type filter
        foreach ($types as $key => $type) {

            //  Convert " store " to "Store"
            $types[$key] = ucfirst(strtolower(trim($type)));

        }

        if ( $reports && count($types) ) {

            $reports->wherein('owner_type', $types);

        }

        //  Return the reports
        return $reports;
    }

    /**
     *  This method filters the reports by start date
     */
    public function filterResourcesByStartDate($reports, $start_date)
    {
        return $reports->startDate($start_date);
    }

    /**
     *  This method filters the reports by end date
     */
    public function filterResourcesByEndDate($reports, $end_date)
    {
        return $reports->endDate($end_date);
    }

    /**
     *
     */
    public function getResourceStatistics($data = [], $builder = null)
    {
        //  Set the accuracy
        $accuracy = strtolower($data['accuracy'] ?? 'months');

        //  Return a list of payment methods
        $payment_methods = \App\PaymentMethod::all();

        //  Return a list of Reports (Don't paginate or convert to API Format)
        $reports = (new \App\Report)->getResources($data, $builder, false, false);

        foreach([
                'store' => ['Created', 'Removed'],
                'location' => ['Created', 'Removed', 'Product Existence', 'Coupon Existence'],
                'order' => ['Created', 'Cancelled'],
                'cart' => ['Created', 'Recovered', 'Abandoned', 'Converted', [
                    'name' => 'Potential',
                    'values' => ['Created', 'Recovered', 'Abandoned', 'Converted']]
                ],
                'product' => ['Created', 'Removed'],
                'coupon' => ['Created', 'Removed'],
                'instant_cart' => ['Created', 'Removed'],
                'transaction' => ['Created'],
                'subscription' => ['Created'],
                'short_code' => ['Created', 'Recycled']
            ] as $resource_name => $resource_types){

            //  Get the reports that match the resource
            $resource_reports = collect($reports)->where('owner_type', $resource_name)->sortBy('created_at');

            //  Count the total resource reports
            $total_resource_reports = $resource_reports->count();

            //  Set the variable name e.g store_report_over_time, order_report_over_time
            $variable = $resource_name . '_report_over_time';

            //  Foreach resource type e.g Created, Removed, e.t.c
            foreach($resource_types as $resource_type){

                /****************************
                 *  LINE CHART REPORTS      *
                 ***************************/

                /**
                 *  store_report_over_time['created'] = [...]
                 *  cart_report_over_time['abandoned'] = [...]
                 *  product_report_over_time['removed'] = [...]
                 *  e.t.c
                 */
                $resource_type_name = is_array($resource_type) ? $resource_type['name'] : $resource_type;
                $resource_type_values = is_array($resource_type) ? $resource_type['values'] : [$resource_type];

                $$variable[strtolower($resource_type_name)] = $resource_reports->whereIn('type', $resource_type_values)->groupBy(function ($report) use ($accuracy){

                    //  Group on accuracy
                    return Carbon::parse($report['created_at'])->format($this->dateAccuracyFormat($accuracy));

                })->map(function($collection_by_accuracy, $accuracy) use ($resource_name, $resource_type_name, $resource_type_values){

                    $curr_total = collect($collection_by_accuracy)->count();

                    $data = [
                        'name' => $accuracy,
                        'count' => $curr_total,
                    ];

                    foreach($resource_type_values as $resource_type_value){

                        if(in_array($resource_type_value, ['Product Existence', 'Coupon Existence'])){

                            $existing_collection = collect($collection_by_accuracy)->filter(function($report){

                                return $report['metadata']['exists'] == true;

                            })->all();

                            $non_existing_collection = collect($collection_by_accuracy)->filter(function($report){

                                return $report['metadata']['exists'] == false;

                            })->all();

                            //  Remove the count, its not necessary
                            unset($data['count']);

                            $data['count_existence'] = collect($existing_collection)->count();

                            $data['count_non_existence'] = collect($non_existing_collection)->count();

                        }

                        if($resource_name == 'subscription'){

                            $amount_total = collect($collection_by_accuracy)->sum(function ($subscription) {
                                return $subscription['metadata']['price'];
                            });

                            $data['amount'] = $amount_total;

                        }

                        if($resource_name == 'transaction'){

                            $amount_total = collect($collection_by_accuracy)->sum(function ($transaction) {
                                return $transaction['metadata']['amount'];
                            });

                            $data['amount'] = $amount_total;

                        }

                        if($resource_name == 'cart'){

                            if(in_array($resource_type_value, ['Created', 'Converted', 'Abandoned'])){

                                $sub_total = collect($collection_by_accuracy)->sum(function ($report) {
                                    return $report['metadata']['sub_total'];
                                });

                                $grand_total = collect($collection_by_accuracy)->sum(function ($report) {
                                    return $report['metadata']['grand_total'];
                                });

                                $delivery_fee_total = collect($collection_by_accuracy)->sum(function ($report) {
                                    return $report['metadata']['delivery_fee'];
                                });

                                $coupon_and_sale_discount_total = collect($collection_by_accuracy)->sum(function ($report) {
                                    return $report['metadata']['coupon_and_sale_discount_total'];
                                });

                                $data['sub_total'] = $sub_total;
                                $data['grand_total'] = $grand_total;
                                $data['delivery_fee_total'] = $delivery_fee_total;
                                $data['coupon_and_sale_discount_total'] = $coupon_and_sale_discount_total;

                            }


                            /*
                            "sub_total": 75,
                            "owner_type": "order",
                            "grand_total": 60,
                            "total_items": 3,
                            "total_coupons": 1,
                            "coupon_total": 15,
                            "delivery_fee": 0,
                            "instant_cart_id": null,
                            "total_unique_items": 1,
                            "allow_free_delivery": false,
                            "sale_discount_total": 0,
                            "coupon_and_sale_discount_total": 15
                            */

                        }

                    }

                    return $data;

                })->values()->toArray();

            }

            /**
             *  We need to make each resource type to have the same number of xAxis values.
             *  Each report has multiple sets of data e.g:
             *
             *  $store_report_over_time = [
             *      'created' => [ ... ],   //  Data to plot stores created
             *      'removed' => [ ... ],   //  Data to plot stores removed
             *  ]
             *
             *  However often times the data of the "created series" might not correlate with
             *  the data of the "removed series" e.g the created series might have data for
             *  the 1st 2nd and 3rd of June while the removed series only has data for the
             *  1st and 3rd of June. The missing data of the 2nd of June will cause the
             *  charts to fail to render correctly since the graph lines do not have
             *  x-axis data that matches properly. We need to have logic to default
             *  missing values to zero (0) so that the data is available but is set
             *  to zero (0). This will allow us to plot graphs with multi-series
             *  support (Supports multiple plotted lines)
             *
             *  The code below attempts to solve this issue
             *
             */

            $xAxisDates = [];

            //  Foreach resource type e.g Created, Removed, e.t.c
            foreach($resource_types as $resource_type){

                $resource_type_name = is_array($resource_type) ? $resource_type['name'] : $resource_type;
                $resource_type_values = is_array($resource_type) ? $resource_type['values'] : [$resource_type];

                foreach($resource_type_values as $resource_type_value){

                    /**
                     *  Final Result:
                     *
                     *  $xAxisDates = [
                     *      "01 Jul 2021"
                     *      "03 Jul 2021"
                     *      "04 Jul 2021"
                     *      "05 Jul 2021"
                     *      "06 Jul 2021"
                     *      "07 Jul 2021"
                     *      "08 Jul 2021"
                     *      "21 Jul 2021"
                     *  ];
                     */
                    $xAxisDates = collect($xAxisDates)->merge( collect($$variable[strtolower($resource_type_value)])->pluck('name') )->unique()->values()->sortBy(function ($date) use ($accuracy){

                        //  Make sure the dates are in correct order (Must match calender order)
                        return Carbon::createFromFormat($this->dateAccuracyFormat($accuracy), $date)->timestamp;

                    });

                }

            }

            //  Foreach resource type e.g Created, Removed, e.t.c
            foreach($resource_types as $resource_type){

                $resource_type_name = is_array($resource_type) ? $resource_type['name'] : $resource_type;
                $resource_type_values = is_array($resource_type) ? $resource_type['values'] : [$resource_type];

                foreach($resource_type_values as $resource_type_value){

                    $updatedSeries = [];

                    //  $xAxisDate = "01 Jul 2021", "03 Jul 2021", "04 Jul 2021", e.t.c
                    foreach($xAxisDates as $key => $xAxisDate){

                        /**
                         *  $$variable[strtolower($resource_type_value) = [
                         *      [
                         *          "name" => "01 Jul 2021",
                         *          "count" => 2
                         *      ],
                         *      [
                         *          "name" => "03 Jul 2021",
                         *          "count" => 4
                         *      ],
                         *      [
                         *          "name" => "04 Jul 2021",
                         *          "count" => 1
                         *      ],
                         *      e.t.c
                         *  ];
                         *
                         *  ----------------------------------------
                         *
                         *  $plotData = [
                         *      "name" => "01 Jul 2021",
                         *      "count" => 2
                         *  ];
                         */
                        $plotData = collect($$variable[strtolower($resource_type_value)])->firstWhere('name', $xAxisDate);

                        //  If the
                        if( $plotData ){

                            //  Set the existing plot data
                            array_push($updatedSeries, $plotData);

                        }else{

                            if(in_array($resource_type_value, ['Product Existence', 'Coupon Existence'])){

                                //  Set the missing plot data
                                array_push($updatedSeries, [
                                    'name' => $xAxisDate,
                                    'count_existence' => 0,
                                    'count_non_existence' => 0
                                ]);

                            }elseif($resource_name == 'cart' && in_array($resource_type_value, ['Created', 'Converted', 'Abandoned'])){

                                //  Set the missing plot data
                                array_push($updatedSeries, [
                                    'name' => $xAxisDate,
                                    'count' => 0,
                                    'sub_total' => 0,
                                    'grand_total' => 0,
                                    'delivery_fee_total' => 0,
                                    'coupon_and_sale_discount_total' => 0
                                ]);

                            }else{

                                //  Set the missing plot data
                                array_push($updatedSeries, [
                                    'name' => $xAxisDate,
                                    'count' => 0
                                ]);

                            }

                        }

                    }

                    //  Set the updated series
                    $$variable[strtolower($resource_type_value)] = $updatedSeries;

                }

            }

            /****************************
             *  PIE CHART REPORTS      *
             ***************************/

            //  Cart reports
            if( $resource_name == 'cart' ){

                //  Carts by conversion and abandonment chart data
                $cart_by_conversion_and_abandonment = collect($resource_reports)->whereIn('type', ['Abandoned', 'Converted'])->groupBy(function ($report) {

                    //  Group on report type e.g Abandoned or Converted
                    return $report->type;

                })->map(function($collection, $type) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => $type,
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $cart_by_conversion_and_abandonment_summary = count($cart_by_conversion_and_abandonment)
                    ? 'Shopping carts are distributed from highest to lowest in the following order: ' . $this->wrapInTags(
                        collect($cart_by_conversion_and_abandonment)->map(function($method) use($cart_by_conversion_and_abandonment){

                            $total = collect($cart_by_conversion_and_abandonment)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $cart_by_conversion_and_abandonment = [
                    'data' => $cart_by_conversion_and_abandonment,
                    'summary' => $cart_by_conversion_and_abandonment_summary
                ];


                //  Carts by abandonment and recovery chart data
                $cart_by_abandonment_and_recovery = collect($resource_reports)->whereIn('type', ['Abandoned', 'Recovered'])->groupBy(function ($report) {

                    //  Group on report type e.g Abandoned or Recovered
                    return $report->type;

                })->map(function($collection, $type) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => $type,
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $cart_by_abandonment_and_recovery_summary = count($cart_by_abandonment_and_recovery)
                    ? 'Shopping carts are distributed from highest to lowest in the following order: ' . $this->wrapInTags(
                        collect($cart_by_abandonment_and_recovery)->map(function($method) use($cart_by_abandonment_and_recovery){

                            $total = collect($cart_by_abandonment_and_recovery)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $cart_by_abandonment_and_recovery = [
                    'data' => $cart_by_abandonment_and_recovery,
                    'summary' => $cart_by_abandonment_and_recovery_summary
                ];
            }

            //  Location product reports
            if( $resource_name == 'location' ){

                //  Location product traffic by action chart data
                $location_product_by_existence = collect($resource_reports)->where('type', 'Product Existence')->groupBy(function ($report) {

                    //  Group on location product action
                    return $report->metadata['exists'] ? 'Has products' : 'Doesn\'t have products';

                })->map(function($collection, $product_existence_action) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => $product_existence_action,
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $location_product_by_existence_summary = count($location_product_by_existence)
                    ? 'Store locations with products during user shopping are in the following order: ' . $this->wrapInTags(
                        collect($location_product_by_existence)->map(function($method) use($location_product_by_existence){

                            $total = collect($location_product_by_existence)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $location_product_by_existence = [
                    'data' => $location_product_by_existence,
                    'summary' => $location_product_by_existence_summary
                ];


                //  Location coupon traffic by action chart data
                $location_coupon_by_existence = collect($resource_reports)->where('type', 'Coupon Existence')->groupBy(function ($report) {

                    //  Group on location coupon action
                    return $report->metadata['exists'] ? 'Has coupons' : 'Doesn\'t have coupons';

                })->map(function($collection, $coupon_existence_action) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => $coupon_existence_action,
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $location_coupon_by_existence_summary = count($location_coupon_by_existence)
                    ? 'Store locations with coupons during user shopping are in the following order: ' . $this->wrapInTags(
                        collect($location_coupon_by_existence)->map(function($method) use($location_coupon_by_existence){

                            $total = collect($location_coupon_by_existence)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $location_coupon_by_existence = [
                    'data' => $location_coupon_by_existence,
                    'summary' => $location_coupon_by_existence_summary
                ];

            }

            //  Short code reports
            if( $resource_name == 'short_code' ){

                //  Short code traffic by action chart data
                $short_code_traffic_by_action = $resource_reports->groupBy(function ($report) {

                    //  Group on short code action
                    return $report->metadata['action'];

                })->map(function($collection, $short_code_action) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => ucfirst(Str::plural($short_code_action)),
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $short_code_traffic_by_action_summary = count($short_code_traffic_by_action)
                    ? 'Activities utilizing the most shortcodes are in the following order: ' . $this->wrapInTags(
                        collect($short_code_traffic_by_action)->map(function($method) use($short_code_traffic_by_action){

                            $total = collect($short_code_traffic_by_action)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $short_code_traffic_by_action = [
                    'data' => $short_code_traffic_by_action,
                    'summary' => $short_code_traffic_by_action_summary
                ];


                //  Short code traffic by sources chart data
                $short_code_traffic_by_sources = $resource_reports->groupBy(function ($report) {

                    //  Group on short code owner type
                    return ucfirst(str_replace('_', ' ', $report->metadata['owner_type']));

                })->map(function($collection, $short_code_sources) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => ucfirst(Str::plural($short_code_sources)),
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $short_code_traffic_by_sources_summary = count($short_code_traffic_by_sources)
                    ? 'Sources utilizing the most shortcodes are in the following order: ' . $this->wrapInTags(
                        collect($short_code_traffic_by_sources)->map(function($method) use($short_code_traffic_by_sources){

                            $total = collect($short_code_traffic_by_sources)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $short_code_traffic_by_sources = [
                    'data' => $short_code_traffic_by_sources,
                    'summary' => $short_code_traffic_by_sources_summary
                ];

            }

            //  Subscription reports
            if( $resource_name == 'subscription' ){

                //  Subscription by plan name chart data
                $subscription_traffic_by_plan_name = $resource_reports->groupBy(function ($report) {

                    //  Group on subscription plan name
                    return $report->metadata['name'];

                })->map(function($collection, $subscription_plan_name) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => $subscription_plan_name,
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $subscription_traffic_by_plan_name_summary = count($subscription_traffic_by_plan_name)
                    ? 'Subscription plans with the highest usage are in the following order: ' . $this->wrapInTags(
                        collect($subscription_traffic_by_plan_name)->map(function($method) use($subscription_traffic_by_plan_name){

                            $total = collect($subscription_traffic_by_plan_name)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% ('.$method['name'].')';

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $subscription_traffic_by_plan_name = [
                    'data' => $subscription_traffic_by_plan_name,
                    'summary' => $subscription_traffic_by_plan_name_summary
                ];


                //  Subscription revenue by plan name chart data
                $subscription_revenue_by_plan_name = $resource_reports->groupBy(function ($report) {

                    //  Group on subscription plan name
                    return $report->metadata['name'];

                })->map(function($collection, $subscription_plan_name){

                    $amount_total = collect($collection)->sum(function ($transaction) {
                        return $transaction['metadata']['price'];
                    });

                    return [
                        'name' => $subscription_plan_name,
                        'amount' => $amount_total
                    ];

                })->sortByDesc('amount')->values()->toArray();

                $subscription_revenue_by_plan_name_summary = count($subscription_revenue_by_plan_name)
                    ? 'Subscription plans generating the highest revenue are in the following order: ' . $this->wrapInTags(
                        collect($subscription_revenue_by_plan_name)->map(function($method) use($subscription_revenue_by_plan_name){

                            $total = collect($subscription_revenue_by_plan_name)->map(function($result){
                                return $result['amount'];
                            })->sum();

                            return  round($method['amount'] / $total * 100, 0).'% ('.$method['name'].')';

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $subscription_revenue_by_plan_name = [
                    'data' => $subscription_revenue_by_plan_name,
                    'summary' => $subscription_revenue_by_plan_name_summary
                ];


                //  Subscription traffic by source types chart data
                $subscription_traffic_by_source_types = $resource_reports->groupBy(function ($report) {

                    //  Group on owner type e.g store, instant_cart, e.t.c
                    return ucfirst(str_replace('_', ' ', $report->metadata['owner_type']));

                })->map(function($collection, $source_type) {

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => Str::plural($source_type),
                        'count' => $curr_total
                    ];

                })->sortByDesc('count')->values()->toArray();

                $subscription_traffic_by_source_types_summary = count($subscription_traffic_by_source_types)
                    ? 'Sources receiving the highest volume of subscriptions are in the following order: ' . $this->wrapInTags(
                        collect($subscription_traffic_by_source_types)->map(function($method) use($subscription_traffic_by_source_types){

                            $total = collect($subscription_traffic_by_source_types)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $subscription_traffic_by_source_types = [
                    'data' => $subscription_traffic_by_source_types,
                    'summary' => $subscription_traffic_by_source_types_summary
                ];


                //  Subscription revenue by source types chart data
                $subscription_revenue_by_source_types = $resource_reports->groupBy(function ($report) {

                    //  Group on owner type e.g store, instant_cart, e.t.c
                    return ucfirst(str_replace('_', ' ', $report->metadata['owner_type']));

                })->map(function($collection, $source_type) {

                    $amount_total = collect($collection)->sum(function ($transaction) {
                        return $transaction['metadata']['price'];
                    });

                    return [
                        'name' => Str::plural($source_type),
                        'amount' => $amount_total
                    ];

                })->sortByDesc('amount')->values()->toArray();

                $subscription_revenue_by_source_types_summary = count($subscription_revenue_by_source_types)
                    ? 'Sources generating the highest subscription revenue are in the following order: ' . $this->wrapInTags(
                        collect($subscription_revenue_by_source_types)->map(function($method) use($subscription_revenue_by_source_types){

                            $total = collect($subscription_revenue_by_source_types)->map(function($result){
                                return $result['amount'];
                            })->sum();

                            return  round($method['amount'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $subscription_revenue_by_source_types = [
                    'data' => $subscription_revenue_by_source_types,
                    'summary' => $subscription_revenue_by_source_types_summary
                ];

            }

            //  Transaction reports
            if( $resource_name == 'transaction' ){

                //  Transaction by payment methods pie data
                $transaction_by_payment_methods = $resource_reports->groupBy(function ($report) {

                    //  Group on payment method id
                    return $report->metadata['payment_method_id'];

                })->map(function($collection, $payment_method_id) use ($payment_methods){

                    $curr_total = collect($collection)->count();
                    $payment_method_name = collect($payment_methods)->where('id', $payment_method_id)->first()->name;

                    return [
                        'name' => $payment_method_name,
                        'count' => $curr_total,
                    ];

                })->sortByDesc('count')->values()->toArray();

                $transaction_by_payment_methods_summary = count($transaction_by_payment_methods)
                    ? 'Payment methods with the highest usage are in the following order: ' . $this->wrapInTags(
                        collect($transaction_by_payment_methods)->map(function($method) use($transaction_by_payment_methods){

                            $total = collect($transaction_by_payment_methods)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $transaction_by_payment_methods = [
                    'data' => $transaction_by_payment_methods,
                    'summary' => $transaction_by_payment_methods_summary
                ];


                //  Transaction revenue by payment methods chart data
                $transaction_revenue_by_payment_methods = $resource_reports->groupBy(function ($report) {

                    //  Group on payment method id
                    return $report->metadata['payment_method_id'];

                })->map(function($collection, $payment_method_id) use ($payment_methods){

                    $payment_method_name = collect($payment_methods)->where('id', $payment_method_id)->first()->name;

                    $amount_total = collect($collection)->sum(function ($transaction) {
                        return $transaction['metadata']['amount'];
                    });

                    return [
                        'name' => $payment_method_name,
                        'amount' => $amount_total
                    ];

                })->sortByDesc('amount')->values()->toArray();

                $transaction_revenue_by_payment_methods_summary = count($transaction_revenue_by_payment_methods)
                    ? 'Payment methods generating the highest revenue are in the following order: ' . $this->wrapInTags(
                        collect($transaction_revenue_by_payment_methods)->map(function($method) use($transaction_revenue_by_payment_methods){

                            $total = collect($transaction_revenue_by_payment_methods)->map(function($result){
                                return $result['amount'];
                            })->sum();

                            return  round($method['amount'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $transaction_revenue_by_payment_methods = [
                    'data' => $transaction_revenue_by_payment_methods,
                    'summary' => $transaction_revenue_by_payment_methods_summary
                ];


                //  Transaction traffic by source types chart data
                $transaction_traffic_by_source_types = $resource_reports->groupBy(function ($report) {

                    //  Group on type e.g Subscription, Order, e.t.c
                    return $report->metadata['type'];

                })->map(function($collection, $source_type) use ($total_resource_reports){

                    $curr_total = collect($collection)->count();

                    return [
                        'name' => Str::plural($source_type),
                        'count' => $curr_total
                    ];

                })->sortByDesc('count')->values()->toArray();

                $transaction_traffic_by_source_types_summary = count($transaction_traffic_by_source_types)
                    ? 'Sources receiving the highest volume of transactions are in the following order: ' . $this->wrapInTags(
                        collect($transaction_traffic_by_source_types)->map(function($method) use($transaction_traffic_by_source_types){

                            $total = collect($transaction_traffic_by_source_types)->map(function($result){
                                return $result['count'];
                            })->sum();

                            return  round($method['count'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $transaction_traffic_by_source_types = [
                    'data' => $transaction_traffic_by_source_types,
                    'summary' => $transaction_traffic_by_source_types_summary
                ];


                //  Transaction revenue by source types chart data
                $transaction_revenue_by_source_types = $resource_reports->groupBy(function ($report) {

                    //  Group on type e.g Subscription, Order, e.t.c
                    return $report->metadata['type'];

                })->map(function($collection, $source_type) {

                    $amount_total = collect($collection)->sum(function ($transaction) {
                        return $transaction['metadata']['amount'];
                    });

                    return [
                        'name' => Str::plural($source_type),
                        'amount' => $amount_total
                    ];

                })->sortByDesc('amount')->values()->toArray();

                $transaction_revenue_by_source_types_summary = count($transaction_revenue_by_source_types)
                    ? 'Sources generating the highest revenue are in the following order: ' . $this->wrapInTags(
                        collect($transaction_revenue_by_source_types)->map(function($method) use($transaction_revenue_by_source_types){

                            $total = collect($transaction_revenue_by_source_types)->map(function($result){
                                return $result['amount'];
                            })->sum();

                            return  round($method['amount'] / $total * 100, 0).'% '.$method['name'];

                        })->join(', ', ' then ') )
                    : 'No data to compose summary';

                $transaction_revenue_by_source_types = [
                    'data' => $transaction_revenue_by_source_types,
                    'summary' => $transaction_revenue_by_source_types_summary
                ];

            }

        }

        return [
            //  Line charts
            'instant_cart_report_over_time' => $instant_cart_report_over_time,
            'subscription_report_over_time' => $subscription_report_over_time,
            'transaction_report_over_time' => $transaction_report_over_time,
            'short_code_report_over_time' => $short_code_report_over_time,
            'location_report_over_time' => $location_report_over_time,
            'product_report_over_time' => $product_report_over_time,
            'coupon_report_over_time' => $coupon_report_over_time,
            'store_report_over_time' => $store_report_over_time,
            'order_report_over_time' => $order_report_over_time,
            'cart_report_over_time' => $cart_report_over_time,

            //  Pie charts
            'transaction_by_payment_methods' => $transaction_by_payment_methods,
            'transaction_traffic_by_source_types' => $transaction_traffic_by_source_types,
            'transaction_revenue_by_source_types' => $transaction_revenue_by_source_types,
            'transaction_revenue_by_payment_methods' => $transaction_revenue_by_payment_methods,

            'subscription_traffic_by_plan_name' => $subscription_traffic_by_plan_name,
            'subscription_revenue_by_plan_name' => $subscription_revenue_by_plan_name,
            'subscription_traffic_by_source_types' => $subscription_traffic_by_source_types,
            'subscription_revenue_by_source_types' => $subscription_revenue_by_source_types,

            'short_code_traffic_by_action' => $short_code_traffic_by_action,
            'short_code_traffic_by_sources' => $short_code_traffic_by_sources,

            'location_product_by_existence' => $location_product_by_existence,
            'location_coupon_by_existence' => $location_coupon_by_existence,

            'cart_by_conversion_and_abandonment' => $cart_by_conversion_and_abandonment,
            'cart_by_abandonment_and_recovery' => $cart_by_abandonment_and_recovery,

        ];
    }

    /**
     *  This method return the appropriate date format by accuracy
     */
    public function dateAccuracyFormat($accuracy)
    {
        //  Group on accuracy
        switch ($accuracy) {
            case 'years':
                return 'Y';
                break;
            case 'months':
                return 'M Y';
                break;
            case 'days':
                return 'd M Y';
                break;
            case 'hours':
                return 'd M Y H:00';
                break;
            case 'minutes':
                return 'd M Y H:i';
                break;
            case 'seconds':
                return 'd M Y H:i:s';
                break;
        }
    }

    /**
     *  This method wraps the chart summary in div tags
     */
    public function wrapInTags($text = '')
    {

        $parts = preg_split('/(,|then)/', $text);

        return collect($parts)->map(function($part){
            return '<span class="font-weight-bold text-primary">'.$part.'</span>';
        })->join(', ', ' then ');
    }

}
